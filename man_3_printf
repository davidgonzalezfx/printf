.Dd 16/3/20               
.Dt _printf 
.Sh NAME                 \" Section Header - required - don't modify
.Nm _printf - format and print data
.\" Use .Nm macro to designate other names for the documented program.

.Sh SYNOPSIS             \" Section Header - required - don't modify
.Nm printf FORMAT [ARGUMENT]...
                 \" Arguments
.Sh DESCRIPTION          \" Section Header - required - don't modify
The functions in the _printf()  produce output according to a for‐
       mat  as  described  below.
       
This function writes the output under the control of a format
       string that specifies how subsequent arguments (or  arguments  accessed
       via the variable-length argument facilities of stdarg(3)) are converted
       for output.
.Pp

        Format of the format string
.Pp

       The format string is a character string, beginning and  ending  in  its
       initial  shift state, if any.  The format string is composed of zero or
       more  directives:  ordinary  characters  (not  %),  which  are   copied
       unchanged  to the output stream; and conversion specifications, each of
       which results in fetching zero or more subsequent arguments.  Each con‐
       version specification is introduced by the character %, and ends with a
       conversion specifier.  In between there may be (in this order) zero  or
       more  flags, an optional minimum field width, an optional precision and
       an optional length modifier.

       The arguments must correspond properly (after type promotion) with  the
       conversion  specifier.  By default, the arguments are used in the order
       given, where each '*' (see Field width and Precision  below)  and  each
       conversion  specifier asks for the next argument (and it is an error if
       insufficiently many arguments are given).  One can also specify explic‐
       itly  which  argument  is  taken,  at  each  place where an argument is
       required, by writing "%m$" instead of '%' and  "*m$"  instead  of  '*',
       where  the  decimal integer m denotes the position in the argument list
       of the desired argument, indexed starting from 1.  Thus,
.Pp

           printf("%*d", width, num);
.Pp

       For some numeric conversions a radix  character  ("decimal  point")  or
       thousands'  grouping  character  is  used.   The  actual character used
       depends on the LC_NUMERIC part of the locale.   The
       POSIX  locale uses '.' as radix character, and does not have a grouping
       character.  Thus,

.Pp

               printf("%'.2f", 1234567.89);
               
.Pp

       results in "1234567.89" in the POSIX locale,  in  "1234567,89"  in  the
       nl_NL locale, and in "1.234.567,89" in the da_DK locale.
.Ar underlined text .
.Pp                     

.Sh  Flag characters
The character % is followed by zero or more of the following flags:

.TP
.B #      
The  value  should  be  converted to an "alternate form".  For o
              conversions, the first character of the output  string  is  made
              zero (by prefixing a 0 if it was not zero already).  For x and X
              conversions, a nonzero result has the string "0x" (or "0X" for X
              conversions)  prepended  to  it.  For a, A, e, E, f, F, g, and G
              conversions, the result will always  contain  a  decimal  point,
              even  if  no digits follow it (normally, a decimal point appears
              in the results of those conversions only if  a  digit  follows).
              For g and G conversions, trailing zeros are not removed from the
              result as they would otherwise be.  For other  conversions,  the
              result is undefined.

.TP
.B 0
The value should be zero padded.  For d, i, o, u, x, X, a, A, e,
              E, f, F, g, and G conversions, the converted value is padded  on
              the  left  with  zeros rather than blanks.  If the 0 and - flags
              both appear, the 0 flag is ignored.  If  a  precision  is  given
              with  a numeric conversion (d, i, o, u, x, and X), the 0 flag is
              ignored.  For other conversions, the behavior is undefined.

.TP
.B  -      
The converted value is to be left adjusted on the  field  bound‐
              ary.  (The default is right justification.)  The converted value
              is padded on the right with blanks, rather than on the left with
              blanks or zeros.  A - overrides a 0 if both are given.
.TP
.B       ' '    
(a  space)  A  blank should be left before a positive number (or
              empty string) produced by a signed conversion.
.TP
.B   +      
A sign (+ or -) should always be placed before a number produced
 Manual page printf(3) line 110/525 30% (press h for help or q to quit)
.Pp


.Sh Conversion specifiers
       A character that specifies the type of conversion to be  applied.   The
       conversion specifiers and their meanings are:
       

.TP
.B       d, i   
The  int  argument is converted to signed decimal notation.  The
              precision, if any, gives the minimum number of digits that  must
              appear;  if  the  converted  value  requires fewer digits, it is
              padded on the left with zeros.   The  default  precision  is  1.
              When  0  is  printed with an explicit precision 0, the output is
              empty.
.TP
.B o, u, x, X, b
              The unsigned int argument is converted to  unsigned  octal  (o),
              unsigned  decimal  (u),  unsigned hexadecimal (x and X), or unsigned binary nota‐
              tion.  The letters abcdef are used for x conversions;  the  let‐
              ters  ABCDEF are used for X conversions.  The precision, if any,
              gives the minimum number of digits that must appear.

.TP
.B       c      
If no l modifier is present, the int argument is converted to an
              unsigned  char, and the resulting character is written.  If an l
              modifier is present, the wint_t  (wide  character)  argument  is
              converted  to  a  multibyte sequence by a call to the wcrtomb(3)
              function, with a conversion state starting in the initial state,
              and the resulting multibyte string is written.

.TP
.B       s      
If  no  l  modifier  is  present:  the  const char * argument is
              expected to be a pointer to an array of character type  (pointer
              to  a string).  Characters from the array are written up to (but
              not including) a terminating null byte ('\0'); if a precision is
              specified,  no more than the number specified are written.  If a
              precision is given, no null byte need be present; if the  preci‐
              sion is not specified, or is greater than the size of the array,
              the array must contain a terminating null byte.

.TP
.B  %    
A '%' is written.  No argument is converted.  The complete  con‐
              version specification is '%%'.
              
              RETURN VALUE
       Upon successful return, these functions return the number of characters
       printed (excluding the null byte used to end output to strings).

       The functions snprintf() and vsnprintf() do not write  more  than  size
       bytes  (including the terminating null byte ('\0')).  If the output was
       truncated due to this limit, then the return value  is  the  number  of
       characters  (excluding the terminating null byte) which would have been
       written to the final string if enough space had been available.   Thus,
       a  return  value  of  size or more means that the output was truncated.
       (See also below under NOTES.)

       If an output error is encountered, a negative value is returned.


.Sh CREDITS

.RS
.nf
- David Gonzalez
- Christian Bedoya
- Santiago Mendieta
.RE
